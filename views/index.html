<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>평림댐 3D 모델링 테스트</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%
        }
    </style>
</head>
<body>
<script src="http://dreamplan7.cafe24.com/canvas2/js/three.js"></script>
<script src="http://dreamplan7.cafe24.com/canvas2/js/OrbitControls.js"></script>
<script src="http://dreamplan7.cafe24.com/canvas2/js/ColladaLoader.js"></script>
<script src="http://dreamplan7.cafe24.com/canvas2/js/Sky.js"></script>
<script src="http://dreamplan7.cafe24.com/canvas2/js/Water.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.js"
        integrity="sha512-Mcz+Mt8k23j06ycA5EJGfyXbtzB6xqEoJxjGftQQoed/zQzem9Lt21LRymjlcm+NUsbF0LOHgfdN8LO8GtKDOw=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script>
    const scene = new THREE.Scene();

    ////////////////////////
    //      GEOMETRY      //
    ////////////////////////

    // 텍스쳐 로드 및 높이파일 설정
    const loader = new THREE.TextureLoader();
    const height = loader.load('/static/pd_depth_black11.jpg');
    const texture = loader.load('/static/pd_depth_color.jpg');
    height.warpS = height.wrapT = THREE.RepeatWrapping;

    // 지면 init
    const geometry = new THREE.PlaneBufferGeometry(256, 256, 128, 128) // segments 가 높을수록 더 세밀한 오브젝트 생성이 가능

    // 저수지 수심 init ( wireframe : 격자표현 )
    const meterial = new THREE.MeshStandardMaterial({
        color          : '0x000000',
        map            : texture,
        displacementMap: height,
        // wireframe: true,
        displacementScale: 64,
        alpha: false,
    });
    meterial.side = THREE.DoubleSide;

    // 지면 객체 init
    const plane = new THREE.Mesh(geometry, meterial);

    // 지면 객체 위치조정
    plane.rotation.x = -Math.PI / 2;

    // 지면 객체 추가
    scene.add(plane);

    ////////////////////////
    //       CAMERA       //
    ////////////////////////

    // 카메라 init ( 카메라 수직 시야 각도, 가로세로 종횡비율, 시야거리 시작지점, 시야거리 끝지점 )
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 500);

    // 렌더러 정의 및 크기 지정, 문서에 추가
    const renderer = new THREE.WebGLRenderer({
        antialias: true,
        preserveDrawingBuffer: true
    });

    // renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setSize(1024,786);

    document.body.appendChild(renderer.domElement); // 모델 div class 에 추가

    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFShadowMap;

    // 카메라 초기 위치 조정
    camera.position.set(150, 150, 50);

    // 카메라 컨트롤 init 및 시야각도 최대, 최소 조정
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enablePan = false;
    controls.minPolarAngle = Math.PI / -2;
    controls.maxPolarAngle = 10;

    // 카메라 최소, 최대 줌 조정
    controls.minDistance = 100;
    controls.maxDistance = 250;

    // 조명
    const light_base = new THREE.AmbientLight(0xf0f0f0); // soft white light
    scene.add(light_base);

    const light_sun = new THREE.DirectionalLight(0x808080, 1.0);
    light_sun.position.set( 200, 200, 300 );
    scene.add(light_sun);
    const shadowBlur = 10;
    light_sun.castShadow = true;
    light_sun.shadow.camera.left = -shadowBlur;
    light_sun.shadow.camera.right = shadowBlur;
    light_sun.shadow.camera.top = shadowBlur;
    light_sun.shadow.camera.bottom = -shadowBlur;

    ////////////////////////
    //        WATER       //
    ////////////////////////

    const waterGeometry = new THREE.PlaneBufferGeometry(256, 256, 32, 32);

    const water = new THREE.Water(
            waterGeometry,
            {
                textureWidth   : 128,
                textureHeight  : 128,
                waterNormals   : new THREE.TextureLoader().load('http://dreamplan7.cafe24.com/canvas/img/waternormals.jpg', function (texture) {

                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;

                }),
                alpha          : true,
                sunDirection   : light_sun.position.clone().normalize(),
                sunColor       : 0xffffff,
                // waterColor     : 0x000000,
                distortionScale: 16,
            }
    );

    // 수면 회전 및 위치
    water.rotation.x = -Math.PI / 2;
    water.position.set(0, 45, 0); // (x, y, z) 값이며 y 값으로 수면 높이 조정 max: 345

    // scene.add(water);

    ////////////////////////
    //        SKY         //
    ////////////////////////

    const sky = new THREE.Sky();

    sky.material.uniforms['turbidity'].value = 10;
    sky.material.uniforms['rayleigh'].value = 2;
    sky.material.uniforms['luminance'].value = 1;
    sky.material.uniforms['mieCoefficient'].value = 0.005;
    sky.material.uniforms['mieDirectionalG'].value = 0.8;

    const parameters = {
        distance   : 400,
        inclination: 0.1,
        azimuth    : 0.05
    };

    const cubeCamera = new THREE.CubeCamera(0.1, 1, 512);
    scene.background = cubeCamera.renderTarget;

    const theta = Math.PI * (parameters.inclination - 0.5);
    const phi = 2 * Math.PI * (parameters.azimuth - 0.5);

    light_sun.position.x = parameters.distance * Math.cos(phi);
    light_sun.position.y = parameters.distance * Math.sin(phi) * Math.sin(theta);
    light_sun.position.z = parameters.distance * Math.sin(phi) * Math.cos(theta);

    sky.material.uniforms['sunPosition'].value = light_sun.position.copy(light_sun.position);
    water.material.uniforms['sunDirection'].value.copy(light_sun.position).normalize();

    cubeCamera.update(renderer, sky);

    ////////////////////////
    //        ETC.        //
    ////////////////////////

    const framesPerSecond = 144;

    // 에니메이션 효과를 자동으로 주기 위한 보조 기능입니다.
    const animate = function () {
        // 프레임 처리
        setTimeout(function () {
            requestAnimationFrame(animate);
        }, 24 / framesPerSecond);

        water.material.uniforms['time'].value += 5 / 60.0;

        // 랜더링을 수행합니다.
        renderer.render(scene, camera);
    };
    animate();

</script>
</body>
</html>
